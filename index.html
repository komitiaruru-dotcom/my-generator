<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>「五感」描写辞典 </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Creative Plum -->
    <!-- Application Structure Plan: ユーザーからのUI/UXに関するフィードバック（コンテンツの重なりと可読性の低さ）を受け、レイアウトを全面的に刷新。従来の左右2分割・固定（sticky）レイアウトを廃止し、上から下へと流れる単一カラム構成に変更。これにより、①ヘッダー → ②入力 → ③結果表示、という操作フローが明確になり、要素の重なりという根本的な問題を解消。結果表示エリアにはレスポンシブグリッドを採用し、画面サイズに応じてカードが最適に配置されるようにした。この構造は、あらゆるデバイスで直感的かつ快適なユーザー体験を提供するための最適なソリューションであると判断。 -->
    <!-- Visualization & Content Choices: 
        - 入力エリア (Input Area): Report Info -> ユーザーが描写したい情景やテーマ。 Goal -> ユーザーからAIへの指示を受け取る。 Viz/Presentation -> ページ上部に配置された独立したカードセクション (HTML/CSS)。 Interaction -> ユーザーが自由記述で入力。 Justification -> ページ上部に固定することで、ユーザーの最初の操作を明確にガイド。
        - ✨ AI五感描写リスト (AI Sensory Description List): Report Info -> 入力された情景。 Goal -> 五感に基づいた具体的な描写のアイデアを提供する。 Viz/Presentation -> レスポンシブグリッドレイアウト内のカードリスト (HTML/CSS Grid)。 Interaction -> 「描写を生成」ボタンでAPIを呼び出し、入力エリアの下に結果を動的に表示。 Justification -> グリッドレイアウトは、複数のカード情報を一覧で比較するのに優れている。画面幅に応じて列数が自動調整されるため、PCでもスマートフォンでも高い可読性を維持できる。APIのJSONモード利用は継続。
        - ✨ ショートストーリー自動生成 (Short Story Generation): Report Info -> 生成された五感の描写と元のテーマ。 Goal -> アイデアを具体的な物語の文章に昇華させる。 Viz/Presentation -> 結果エリアの下部に追加される専用カード (HTML/CSS)。 Interaction -> 新たな「ショートストーリーを生成」ボタンでAPIを呼び出し、物語を生成・表示。 Justification -> 生成された描写を実用的な文章へと繋げることで、ツールの価値を大幅に向上させる。ユーザーの創作プロセスを次の段階へ進める強力な後押しとなる。
        - ✨ 登場人物のアイデア生成 (Character Idea Generation): Report Info -> 生成された情景。 Goal -> 物語を動かすキャラクターを創造する。 Viz/Presentation -> 結果エリアに追加される専用カード (HTML/CSS)。 Interaction -> 「登場人物を生成」ボタンでAPIを呼び出し、構造化されたキャラクタープロフィールを表示。 Justification -> 情景からキャラクターへと発想を広げ、物語の構成要素を具体化する新機能。
        - ✨ 登場人物のモノローグ生成 (Character Monologue Generation): Report Info -> 生成された情景や物語。 Goal -> キャラクターの心情や内面を掘り下げる。 Viz/Presentation -> 結果エリアに追加される専用カード (HTML/CSS)。 Interaction -> 「モノローグを生成」ボタンでAPIを呼び出し、キャラクターの心の声を表示。 Justification -> 情景描写からキャラクター描写へと創作の焦点を移行させ、物語に深みを与える新機能。
        - ✨ プロットアイデア生成 (Plot Idea Generation): Report Info -> 生成された情景や物語の冒頭。 Goal -> 物語の次の展開やプロットのヒントを提供する。 Viz/Presentation -> 結果エリアの最後に追加される専用カード (HTML/CSS)。 Interaction -> 「『次に何が起こる？』アイデアを生成」ボタンでAPIを呼び出し、3つの異なるプロット案を表示。 Justification -> 創作における「次の一手」を支援し、物語の停滞を防ぐ。アイデア出しからプロット構築までをシームレスに繋ぐ重要な機能。
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'M PLUS Rounded 1c', 'Noto Sans JP', sans-serif;
            background-image: url('https://images.unsplash.com/photo-1579546929518-9e396f3cc809?q=80&w=2070&auto=format&fit=crop');
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
        }
        .glass-card {
            background-color: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .output-card, .story-card, .plot-card, .monologue-card, .character-card {
            border-left: 4px solid;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .output-card:hover, .story-card:hover, .plot-card:hover, .monologue-card:hover, .character-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);
        }
        .loader {
            border: 4px solid #e5e7eb;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
            transition: background-color 0.3s ease;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-primary:disabled {
            background-color: #a5b4fc;
            cursor: not-allowed;
        }
        #results-state, #short-story-section, #plot-ideas-section, #monologue-section, #character-ideas-section {
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #results-state.visible, #short-story-section.visible, #plot-ideas-section.visible, #monologue-section.visible, #character-ideas-section.visible {
            opacity: 1;
        }
        #story-output, #plot-output, #monologue-output, #character-output {
            white-space: pre-wrap;
            line-height: 1.75;
        }
    </style>
</head>
<body class="antialiased text-gray-800">

    <div class="container mx-auto max-w-4xl p-4 md:p-8">
        
        <!-- Header -->
        <header class="text-center mb-8">
            <div class="inline-block glass-card rounded-2xl shadow-lg p-4 md:p-6">
                <div class="flex items-center justify-center mb-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-indigo-600 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v11.494m-9-5.747h18" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.58 5.582A6.5 6.5 0 0117.75 12a6.5 6.5 0 01-2.17 6.418M8.42 18.418A6.5 6.5 0 016.25 12a6.5 6.5 0 012.17-6.418" />
                    </svg>
                    <h1 class="text-3xl md:text-4xl font-bold text-gray-900">「五感」描写辞典</h1>
                </div>
                <p class="text-gray-700">あなたの創作世界に、息づかいとリアリティを。</p>
            </div>
        </header>

        <main>
            <!-- Input Section -->
            <section id="input-section" class="glass-card rounded-2xl shadow-lg p-6 md:p-8 mb-8">
                <h2 class="text-xl font-bold text-gray-800 mb-2">情景を入力</h2>
                <p class="text-gray-600 mb-6 text-sm">描写したい情景やテーマを入力してください。</p>

                <div class="space-y-4">
                    <div>
                        <textarea id="scene-input" rows="4" class="w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition" placeholder="例：真夜中の図書室、雨上がりのアスファルト、未来都市のラーメン屋台…"></textarea>
                    </div>
                    <button id="generate-btn" class="w-full btn-primary font-bold py-3 px-4 rounded-lg shadow-md flex items-center justify-center text-lg">
                        <span id="btn-text">描写を生成</span>
                        <div id="btn-loader" class="hidden w-6 h-6 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                    </button>
                </div>

                <div class="mt-8">
                    <h3 class="font-semibold text-gray-700 mb-2 text-sm">試してみよう:</h3>
                    <div class="flex flex-wrap gap-2">
                        <button class="example-btn text-xs bg-indigo-100 text-indigo-700 py-1 px-3 rounded-full hover:bg-indigo-200 transition">霧の立ち込める森</button>
                        <button class="example-btn text-xs bg-indigo-100 text-indigo-700 py-1 px-3 rounded-full hover:bg-indigo-200 transition">夏の終わりの花火大会</button>
                        <button class="example-btn text-xs bg-indigo-100 text-indigo-700 py-1 px-3 rounded-full hover:bg-indigo-200 transition">サイバーパンクな街の裏通り</button>
                    </div>
                </div>
            </section>

            <!-- Loading State (centralized) -->
            <div id="loading-state" class="hidden flex-col items-center justify-center text-center text-gray-500 h-full min-h-[300px] my-8">
                <div class="loader"></div>
                <p class="mt-4 text-lg font-semibold">AIが描写を生成中です...</p>
                <p class="text-sm text-gray-400">素晴らしいアイデアを練っています</p>
            </div>

            <!-- History Title (appears after first generation) -->
            <div id="history-title" class="hidden text-center my-8">
                 <div class="inline-block glass-card rounded-2xl shadow-lg p-4 md:p-6">
                    <div class="flex items-center justify-between gap-8">
                        <h2 class="text-2xl md:text-3xl font-bold text-gray-900">✨ 創作履歴</h2>
                        <button id="clear-history-btn" class="text-sm text-red-500 hover:text-red-700 hover:bg-red-100 rounded-lg p-2 transition-colors flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                            履歴をクリア
                        </button>
                    </div>
                </div>
            </div>

            <!-- History Log Container -->
            <section id="history-log" class="space-y-12">
                <!-- New history blocks will be prepended here by JavaScript -->
            </section>

            <!-- Initial State (visible only at the beginning) -->
            <section id="initial-state-container">
                <div id="initial-state" class="glass-card flex flex-col items-center justify-center text-center text-gray-600 h-full rounded-2xl p-8 min-h-[300px]">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mb-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />
                    </svg>
                    <h2 class="text-xl font-bold mb-2">ここに描写のアイデアが表示されます</h2>
                    <p>上のボックスにテーマを入力し、「描写を生成」ボタンを押してください。</p>
                </div>
            </section>

        </main>

        <footer class="text-center text-xs text-white/80 mt-8">
            Powered by Google Gemini API
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const sceneInput = document.getElementById('scene-input');
            const generateBtn = document.getElementById('generate-btn');
            const btnText = document.getElementById('btn-text');
            const btnLoader = document.getElementById('btn-loader');
            
            const loadingState = document.getElementById('loading-state');
            const initialStateContainer = document.getElementById('initial-state-container');
            const historyLog = document.getElementById('history-log');
            const historyTitle = document.getElementById('history-title');
            const clearHistoryBtn = document.getElementById('clear-history-btn');

            // --- State & History Management ---
            let historyData = [];
            const HISTORY_STORAGE_KEY = 'creativeWritingHistory';
            let historyCounter = 0;

            // --- API & Config ---
            const apiKey = "AIzaSyAHltGAm3g3C6Jx0rZ_xWYXSLLWwYSFZtE";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const senseConfig = {
                sight: { title: "視覚 - Sight", color: "#3b82f6", icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>` },
                sound: { title: "聴覚 - Sound", color: "#10b981", icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.636 18.364a9 9 0 010-12.728m12.728 0A5 5 0 0115.536 8.464" /></svg>` },
                smell: { title: "嗅覚 - Smell", color: "#f59e0b", icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 18H5a2 2 0 01-2-2V8a2 2 0 012-2h2.586a1 1 0 01.707.293l4.414 4.414a1 1 0 01.293.707V18a2 2 0 01-2 2z" /><path stroke-linecap="round" stroke-linejoin="round" d="M13 18V6a2 2 0 012-2h2a2 2 0 012 2v12a2 2 0 01-2 2h-2a2 2 0 01-2-2z" /></svg>` },
                taste: { title: "味覚 - Taste", color: "#ef4444", icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 18a6 6 0 006-6H6a6 6 0 006 6z" /><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v1m0 16v-2m-7.071-7.071H3m18 0h-1.929M5.636 5.636L4.222 4.222m15.556 15.556l-1.414-1.414M12 4a8 8 0 018 8h-2a6 6 0 00-6-6V4z" /></svg>` },
                touch: { title: "触覚 - Touch", color: "#8b5cf6", icon: `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" /></svg>` }
            };

            // --- History Functions ---
            function saveHistory() {
                localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(historyData));
            }

            function loadHistory() {
                const savedHistory = localStorage.getItem(HISTORY_STORAGE_KEY);
                if (savedHistory) {
                    historyData = JSON.parse(savedHistory);
                    if (historyData.length > 0) {
                        historyLog.innerHTML = ''; // Clear initial state message
                        historyData.forEach(entry => addHistoryBlock(entry, false));
                    }
                }
            }

            // --- Event Listeners ---
            loadHistory(); // Load history on page start

            clearHistoryBtn.addEventListener('click', () => {
                if (confirm('本当にすべての履歴を削除しますか？この操作は元に戻せません。')) {
                    localStorage.removeItem(HISTORY_STORAGE_KEY);
                    historyData = [];
                    historyLog.innerHTML = '';
                    historyTitle.classList.add('hidden');
                    initialStateContainer.classList.remove('hidden');
                }
            });

            const exampleBtns = document.querySelectorAll('.example-btn');
            exampleBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    sceneInput.value = btn.textContent;
                    generateBtn.click();
                });
            });

            generateBtn.addEventListener('click', async () => {
                const scene = sceneInput.value.trim();
                if (!scene) {
                    alert('情景・テーマを入力してください。');
                    return;
                }

                setLoadingState(true);

                const systemPrompt = `あなたはプロの作家であり、情景描写の達人です。ユーザーが提示したお題や情景に対して、五感（視覚、聴覚、嗅覚、味覚、触覚）をフル活用した、具体的で詩的な描写のアイデアをそれぞれ3～5個ずつ提供してください。`;
                const userQuery = `お題: ${scene}`;
                
                try {
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "OBJECT",
                                properties: {
                                    sight: { type: "ARRAY", items: { type: "STRING" } },
                                    sound: { type: "ARRAY", items: { type: "STRING" } },
                                    smell: { type: "ARRAY", items: { type: "STRING" } },
                                    taste: { type: "ARRAY", items: { type: "STRING" } },
                                    touch: { type: "ARRAY", items: { type: "STRING" } },
                                }
                            }
                        }
                    };

                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { throw new Error(`API Error: ${response.statusText}`); }
                    
                    const result = await response.json();
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (jsonText) {
                        const descriptions = JSON.parse(jsonText);
                        const newEntry = {
                            id: Date.now(), // Unique ID
                            scene: scene,
                            descriptions: descriptions,
                            timestamp: new Date().toLocaleString('ja-JP')
                        };
                        addHistoryBlock(newEntry, true);
                    } else {
                         throw new Error('AIからの応答が不正です。');
                    }

                } catch (error) {
                    console.error('Error generating descriptions:', error);
                    displayError(scene);
                } finally {
                    setLoadingState(false);
                }
            });

            // --- UI Update Functions ---
            function setLoadingState(isLoading) {
                if (isLoading) {
                    generateBtn.disabled = true;
                    btnText.classList.add('hidden');
                    btnLoader.classList.remove('hidden');
                    initialStateContainer.classList.add('hidden');
                    loadingState.classList.remove('hidden');
                    loadingState.classList.add('flex');
                } else {
                    generateBtn.disabled = false;
                    btnText.classList.remove('hidden');
                    btnLoader.classList.add('hidden');
                    loadingState.classList.add('hidden');
                    loadingState.classList.remove('flex');
                }
            }

            function addHistoryBlock(entry, save = true) {
                const blockId = `history-${entry.id}`;

                if (historyTitle.classList.contains('hidden')) {
                    historyTitle.classList.remove('hidden');
                    initialStateContainer.classList.add('hidden');
                }

                const historyBlock = document.createElement('div');
                historyBlock.id = blockId;
                historyBlock.className = 'glass-card rounded-2xl shadow-lg';
                
                historyBlock.innerHTML = `
                    <div class="history-header p-6 cursor-pointer border-b border-gray-300">
                        <div class="flex justify-between items-center">
                            <div>
                                <p class="text-sm text-gray-600">${entry.timestamp}</p>
                                <h3 class="text-xl font-bold text-gray-800 mt-2">テーマ: 「${entry.scene}」</h3>
                            </div>
                            <svg class="w-6 h-6 text-gray-600 transition-transform transform rotate-180" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                            </svg>
                        </div>
                    </div>
                    <div class="history-content p-6 md:p-8 space-y-8">
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" id="results-${blockId}">
                        </div>
                        <div class="space-y-6" id="actions-${blockId}">
                        </div>
                    </div>
                `;

                historyLog.prepend(historyBlock);

                const resultsContainer = historyBlock.querySelector(`#results-${blockId}`);
                for (const sense in senseConfig) {
                    if (entry.descriptions[sense] && entry.descriptions[sense].length > 0) {
                        const card = createSenseCard(sense, entry.descriptions[sense]);
                        resultsContainer.appendChild(card);
                    }
                }
                
                const actionsContainer = historyBlock.querySelector(`#actions-${blockId}`);
                
                const storySection = createActionSection('story', 'ショートストーリー生成', '#d946ef', 'この描写からショートストーリーを生成', '生成された描写をもとに、AIが短い物語を作成します。', blockId, entry.scene, entry.descriptions);
                const characterSection = createActionSection('character', '登場人物のアイデア生成', '#f59e0b', '登場人物を生成', 'この情景にぴったりのキャラクターをAIが創造します。', blockId, entry.scene, entry.descriptions);
                const monologueSection = createActionSection('monologue', '登場人物のモノローグ生成', '#3b82f6', 'モノローグを生成', 'この情景を体験している人物の心の声を生成します。', blockId, entry.scene, entry.descriptions);
                const plotSection = createActionSection('plot', '「次に何が起こる？」アイデア生成', '#f97316', 'プロットアイデアを生成', '物語の続きが思いつかない時に。AIが3つの異なる展開を提案します。', blockId, entry.scene, entry.descriptions);

                actionsContainer.appendChild(storySection);
                actionsContainer.appendChild(characterSection);
                actionsContainer.appendChild(monologueSection);
                actionsContainer.appendChild(plotSection);

                // Collapsible logic
                const header = historyBlock.querySelector('.history-header');
                const content = historyBlock.querySelector('.history-content');
                const icon = header.querySelector('svg');

                header.addEventListener('click', () => {
                    content.classList.toggle('hidden');
                    icon.classList.toggle('rotate-180');
                });

                // Start open, then fade in
                historyBlock.style.opacity = 0;
                setTimeout(() => { historyBlock.style.transition = 'opacity 0.5s ease-in-out'; historyBlock.style.opacity = 1; }, 10);

                if (save) {
                    historyData.unshift(entry);
                    saveHistory();
                }
            }

            function createSenseCard(sense, items) {
                const config = senseConfig[sense];
                const cardDiv = document.createElement('div');
                cardDiv.className = 'output-card glass-card shadow-lg rounded-xl';
                cardDiv.style.borderColor = config.color;
                const listItems = items.map(item => `<li class="pb-1">${item.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</li>`).join('');
                cardDiv.innerHTML = `
                    <div class="p-5">
                        <div class="flex items-center mb-3" style="color: ${config.color};">
                            ${config.icon}
                            <h2 class="text-xl font-bold">${config.title}</h2>
                        </div>
                        <ul class="list-disc list-inside space-y-2 text-gray-700 pl-2">${listItems}</ul>
                    </div>
                `;
                return cardDiv;
            }
            
            function createActionSection(type, title, color, buttonText, description, blockId, scene, descriptions) {
                const sectionId = `${type}-${blockId}`;
                const sectionDiv = document.createElement('div');
                sectionDiv.className = `${type}-card glass-card shadow-lg rounded-xl p-6 md:p-8`;
                sectionDiv.style.borderColor = color;

                sectionDiv.innerHTML = `
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">✨ ${title}</h2>
                    <p class="text-gray-700 mb-6 text-sm">${description}</p>
                    <button id="btn-${sectionId}" class="w-full text-white font-bold py-3 px-4 rounded-lg shadow-md flex items-center justify-center text-lg transition" style="background-color: ${color};">
                        <span id="btn-text-${sectionId}">${buttonText}</span>
                        <div id="btn-loader-${sectionId}" class="hidden w-6 h-6 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                    </button>
                    <div id="output-container-${sectionId}" class="mt-6 hidden">
                        <div id="output-${sectionId}" class="p-4 bg-white/50 rounded-lg text-gray-800 border border-gray-200 whitespace-pre-wrap line-height-1.75"></div>
                    </div>
                `;
                
                const generateBtn = sectionDiv.querySelector(`#btn-${sectionId}`);
                generateBtn.addEventListener('click', async () => {
                    await handleActionClick(sectionId, type, scene, descriptions);
                });

                return sectionDiv;
            }

            async function handleActionClick(sectionId, type, scene, descriptions) {
                const btn = document.getElementById(`btn-${sectionId}`);
                const btnText = document.getElementById(`btn-text-${sectionId}`);
                const btnLoader = document.getElementById(`btn-loader-${sectionId}`);
                const outputContainer = document.getElementById(`output-container-${sectionId}`);
                const outputDiv = document.getElementById(`output-${sectionId}`);

                btn.disabled = true;
                btnText.classList.add('hidden');
                btnLoader.classList.remove('hidden');
                outputContainer.classList.remove('hidden');
                outputDiv.textContent = '生成中...';

                try {
                    const { systemPrompt, userQuery, generationConfig } = getActionConfig(type, scene, descriptions, outputDiv.textContent);
                    
                    const payload = {
                        contents: [{ parts: [{ text: userQuery }] }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        ...(generationConfig && { generationConfig })
                    };

                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                    
                    const result = await response.json();
                    const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (responseText) {
                        processActionResponse(type, responseText, outputDiv);
                    } else {
                        throw new Error('AIからの応答が不正です。');
                    }
                } catch (error) {
                    console.error(`Error generating ${type}:`, error);
                    outputDiv.textContent = `エラーが発生しました: ${error.message}`;
                } finally {
                    btn.disabled = false;
                    btnText.classList.remove('hidden');
                    btnLoader.classList.add('hidden');
                }
            }

            function getActionConfig(type, scene, descriptions, storyText) {
                const sensoryDetails = Object.entries(descriptions)
                    .filter(([, values]) => values.length > 0)
                    .map(([sense, values]) => `${senseConfig[sense].title}: ${values.join(', ')}`)
                    .join('\n');

                switch (type) {
                    case 'story':
                        return {
                            systemPrompt: `あなたは創造力豊かな作家です。与えられたテーマと五感の描写を基に、読者の心を引き込むような短い物語（200～300字程度）を創作してください。情景だけでなく、キャラクターの心情や行動も少し含めると、より魅力的な物語になります。`,
                            userQuery: `テーマ: ${scene}\n\n五感の描写:\n${sensoryDetails}`
                        };
                    case 'character':
                        return {
                            systemPrompt: `あなたはプロのキャラクターデザイナーです。与えられたテーマの情景にふさわしい、ユニークで魅力的な登場人物を一人作成してください。以下の項目について、具体的に記述してください。`,
                            userQuery: `テーマ: ${scene}`,
                            generationConfig: {
                                responseMimeType: "application/json",
                                responseSchema: {
                                    type: "OBJECT",
                                    properties: {
                                        name: { type: "STRING", description: "キャラクターの名前" },
                                        appearance: { type: "STRING", description: "キャラクターの外見、服装などの特徴" },
                                        personality: { type: "STRING", description: "キャラクターの性格、口調などの特徴" },
                                        reason: { type: "STRING", description: "そのキャラクターがなぜその場所にいるのかの理由" },
                                    }
                                }
                            }
                        };
                    case 'monologue':
                        return {
                            systemPrompt: `あなたはキャラクターの感情を描写するのが得意な小説家です。与えられたテーマ、情景描写、そして短い物語を基に、その場にいる人物の視点から、心の声や感情が伝わる短いモノローグ（150～200字程度）を創作してください。`,
                            userQuery: `テーマ: ${scene}\n\n物語の状況:\n${storyText.includes('生成中') || storyText.includes('エラー') ? '（物語はまだ生成されていませんが、このテーマの情景です）' : storyText}`
                        };
                    case 'plot':
                        return {
                            systemPrompt: `あなたは経験豊富な編集者であり、ストーリーテラーです。与えられたテーマと物語の冒頭部分を基に、「次に何が起こるか」についての興味をそそるプロットのアイデアを3つ、箇条書きで提案してください。それぞれのアイデアは、物語を異なる方向へ導くユニークなものであるべきです。`,
                            userQuery: `テーマ: ${scene}\n\n物語の冒頭:\n${storyText.includes('生成中') || storyText.includes('エラー') ? '（物語はまだ生成されていません）' : storyText}`
                        };
                    default:
                        return {};
                }
            }

            function processActionResponse(type, responseText, outputDiv) {
                if (type === 'character') {
                    const char = JSON.parse(responseText);
                    outputDiv.innerHTML = `
                        <p><strong class="font-semibold text-gray-900">名前:</strong> ${char.name || '未設定'}</p>
                        <p><strong class="font-semibold text-gray-900">外見:</strong> ${char.appearance || '未設定'}</p>
                        <p><strong class="font-semibold text-gray-900">性格:</strong> ${char.personality || '未設定'}</p>
                        <p><strong class="font-semibold text-gray-900">この場所にいる理由:</strong> ${char.reason || '未設定'}</p>
                    `;
                } else {
                    outputDiv.textContent = responseText;
                }
            }
            
            function displayError(scene) {
                historyCounter++;
                const blockId = `history-${historyCounter}`;

                if (historyTitle.classList.contains('hidden')) {
                    historyTitle.classList.remove('hidden');
                }

                const errorBlock = document.createElement('div');
                errorBlock.id = blockId;
                errorBlock.className = 'glass-card rounded-2xl shadow-lg p-6 md:p-8 space-y-4';
                
                const timestamp = new Date().toLocaleString('ja-JP');

                errorBlock.innerHTML = `
                    <div class="border-b border-red-300 pb-4">
                        <p class="text-sm text-gray-600">${timestamp}</p>
                        <h3 class="text-xl font-bold text-red-600 mt-2">テーマ: 「${scene}」</h3>
                    </div>
                    <div class="flex flex-col items-center justify-center text-center text-red-600 h-full rounded-2xl p-8">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <h2 class="text-xl font-bold mb-2">エラーが発生しました</h2>
                        <p>描写の生成に失敗しました。時間をおいて再度お試しください。</p>
                    </div>
                `;
                historyLog.prepend(errorBlock);
            }
        });
    </script>
</body>
</html>
